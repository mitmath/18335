#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble

\renewcommand{\vec}[1]{\mathbf{#1}}

\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{(\roman{enumii})}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\topmargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section*
18.335 Problem Set 1 Solutions
\end_layout

\begin_layout Subsection*
Problem 1: Gaussian elimination
\end_layout

\begin_layout Standard
The inner loop of LU, the loop over rows, subtracts from each row a different
 multiple of the pivot row.
 But this is exactly a rank-1 update 
\begin_inset Formula $U\to U-xy^{T}$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 is the column-vector of multipliers and 
\begin_inset Formula $y^{T}$
\end_inset

 is the pivot row.
 More explicitly, we can rewrite Gaussian elimination without row swaps
 (pivoting) as:
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $U=A$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
for
\series default
 
\begin_inset Formula $k=1$
\end_inset

 
\series bold
to
\series default
 
\begin_inset Formula $m-1$
\end_inset


\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $x=u_{k+1:m,k}/u_{kk}$
\end_inset


\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $U_{k+1:m,k:m}=U_{k+1:m,k:m}-xu_{k,k:m}$
\end_inset


\end_layout

\begin_layout Standard
Note that I have used Matlab notation 
\begin_inset Formula $n:n'$
\end_inset

 to denote ranges (from 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $n'$
\end_inset

) of rows or columns.
 In particular, note that we only have to do a rank-1 update of a submatrix
 of 
\begin_inset Formula $U$
\end_inset

, and that 
\begin_inset Formula $u_{k,k:m}$
\end_inset

 is a row vector of the 
\begin_inset Formula $k$
\end_inset

-th row of 
\begin_inset Formula $U$
\end_inset

 from column 
\begin_inset Formula $k$
\end_inset

 to column 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Subsection*
Problem 2: Asymptotic notation
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Theta$
\end_inset

 means both 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $\Omega$
\end_inset

.
 Let's do one at a time.
 By the definition of 
\begin_inset Formula $O$
\end_inset

, 
\begin_inset Formula $f(n)\leq C_{1}F(n)$
\end_inset

 for 
\begin_inset Formula $n>N_{1}$
\end_inset

 and 
\begin_inset Formula $g(n)\leq C_{2}G(n)$
\end_inset

 for 
\begin_inset Formula $n>N_{2}$
\end_inset

 (no absolute values since the functions were given to be nonnegative),
 for some constants 
\begin_inset Formula $C_{1,2}$
\end_inset

 and 
\begin_inset Formula $N_{1,2}$
\end_inset

.
 If we let 
\begin_inset Formula $C=\max(C_{1},C_{2})$
\end_inset

 and 
\begin_inset Formula $N=\max(N_{1},N_{2})$
\end_inset

, then 
\begin_inset Formula $f(n)+g(n)\leq C_{1}F(n)+C_{2}G(n)\leq C[F(n)+G(n)]$
\end_inset

 for 
\begin_inset Formula $n>N$
\end_inset

, hence 
\begin_inset Formula $f+g$
\end_inset

 is 
\begin_inset Formula $O(F+G)$
\end_inset

.
 Similarly for 
\begin_inset Formula $\Omega$
\end_inset

, replacing 
\begin_inset Formula $\leq$
\end_inset

 with 
\begin_inset Formula $\geq$
\end_inset

 and 
\begin_inset Formula $\max$
\end_inset

 with 
\begin_inset Formula $\min$
\end_inset

, so 
\begin_inset Formula $f+g$
\end_inset

 is 
\begin_inset Formula $\Omega(F+G)$
\end_inset

.
 Hence 
\begin_inset Formula $f+g$
\end_inset

 is 
\begin_inset Formula $\Theta(F+G)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $f(n)\in O[g(n)]\Leftrightarrow|f(n)|\leq C|g(n)|$
\end_inset

 for some 
\begin_inset Formula $C>0$
\end_inset

 and 
\begin_inset Formula $n>N$
\end_inset

 
\begin_inset Formula $\Leftrightarrow|g(n)|\geq C^{-1}|f(n)|$
\end_inset

 for 
\begin_inset Formula $C^{-1}>0$
\end_inset

 and 
\begin_inset Formula $n>N$
\end_inset

 
\begin_inset Formula $\Leftrightarrow g(n)\in\Omega[g(n)]$
\end_inset

.
 Q.E.D.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $f(n)\in O[F(n)]\Leftrightarrow|f(n)|\leq C|F(n)|$
\end_inset

 for 
\begin_inset Formula $n>N$
\end_inset

.
 If 
\begin_inset Formula $h(n)\in O[f(n)+c\, F(n)]$
\end_inset

 then for 
\begin_inset Formula $n>N'$
\end_inset

 we have 
\begin_inset Formula $|h(n)|\leq C'|f(n)+c\, F(n)|\leq C'|f(n)|+C'|c|\,|F(n)|$
\end_inset

 for some 
\begin_inset Formula $C'>0$
\end_inset

.
 For 
\begin_inset Formula $n>\max(N',N)$
\end_inset

, 
\begin_inset Formula $|h(n)|\leq(C'C+C'|c|)\,|F(n)|$
\end_inset

 where 
\begin_inset Formula $C'C+C'|c|>0$
\end_inset

, and thus 
\begin_inset Formula $h(n)\in O[F(n)]$
\end_inset

.
 However, the same inference is not true if we replace 
\begin_inset Formula $O$
\end_inset

 with 
\begin_inset Formula $\Theta$
\end_inset

; as a simple example, consider 
\begin_inset Formula $f(n)=n^{3}$
\end_inset

 and 
\begin_inset Formula $F(n)=n^{3}-n^{2}$
\end_inset

 with 
\begin_inset Formula $c=-1$
\end_inset

: in this case 
\begin_inset Formula $n^{3}\in O(n^{3}-n^{2})$
\end_inset

, but 
\begin_inset Formula $f(n)+c\, F(n)=n^{2}$
\end_inset

 and 
\begin_inset Formula $\Theta(n^{2})$
\end_inset

 is not a subset of 
\begin_inset Formula $\Theta(n^{3}-n^{2})=\Theta(n^{3})$
\end_inset

.
 
\end_layout

\begin_layout Subsection*
Problem 3: Caches and matrix multiplications
\end_layout

\begin_layout Enumerate
See figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:core2"

\end_inset

.
 For discussion of the results, see part (d).
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename core2.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:core2"

\end_inset

Matrix-multiply benchmarks in Matlab 7.6.0.324 (R2008a) on a 2.66GHz Intel Core
 2 duo.
 I attempted to use only one CPU by setting 
\family typewriter
maxNumCompThreads(1)
\family default
, but 
\family typewriter
top
\family default
 showed that it was still using 2 CPUs for some reason.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The only temporal locality in a matrix-vector multiply 
\begin_inset Formula $y=Ax$
\end_inset

 is that the vector 
\begin_inset Formula $x$
\end_inset

 is re-used to multiply against each row of 
\begin_inset Formula $A$
\end_inset

; nothing in 
\begin_inset Formula $A$
\end_inset

 is re-used, as each element of 
\begin_inset Formula $A$
\end_inset

 is needed exactly once.
 Thus, there will always be 
\begin_inset Formula $m^{2}$
\end_inset

 misses to read in 
\begin_inset Formula $A$
\end_inset

.
 Furthermore, 
\begin_inset Formula $x$
\end_inset

 is read in 
\begin_inset Formula $m$
\end_inset

 times, but asymptotically (for large 
\begin_inset Formula $m>Z$
\end_inset

) 
\begin_inset Formula $x$
\end_inset

 will not fit in cache and hence (in the straightforward row-column algorithm)
 every read of 
\begin_inset Formula $x$
\end_inset

 will incur 
\begin_inset Formula $m$
\end_inset

 cache misses (by the time you get back to the first element of 
\begin_inset Formula $x$
\end_inset

, it has left the cache), for 
\begin_inset Formula $m^{2}$
\end_inset

 misses in total.
 Or, technically, with an ideal cache it would store 
\begin_inset Formula $Z-1$
\end_inset

 of the elements in cache and read in the remaining elements one by one,
 for 
\begin_inset Formula $m+(m-1)(m-Z+1)$
\end_inset

 misses, but for large 
\begin_inset Formula $m$
\end_inset

 only the 
\begin_inset Formula $m^{2}$
\end_inset

 leading term matters.
 Thus, there are 
\begin_inset Formula $2m^{2}$
\end_inset

 misses asymptotically, independent of 
\begin_inset Formula $Z$
\end_inset

.
 (Note that, like our analyses in cache, I'm not including cache-line effects.
 If you include cache lines of length 
\begin_inset Formula $L$
\end_inset

 then you get 
\begin_inset Formula $2m^{2}/L$
\end_inset

 misses if 
\begin_inset Formula $A$
\end_inset

 is row-major, or 
\begin_inset Formula $m^{2}+m^{2}/L$
\end_inset

 if 
\begin_inset Formula $A$
\end_inset

 is column-major since it is being read in the 
\begin_inset Quotes eld
\end_inset

wrong
\begin_inset Quotes erd
\end_inset

 order.)
\end_layout

\begin_layout Enumerate
Since 
\begin_inset Formula $x$
\end_inset

 is re-used, we should read 
\begin_inset Formula $x$
\end_inset

 in blocks of size 
\begin_inset Formula $\alpha Z$
\end_inset

 for some fraction 
\begin_inset Formula $\alpha$
\end_inset

 to be determined.
 Then, for each block, we will multiply it by the corresponding block of
 
\begin_inset Formula $\alpha Z$
\end_inset

 columns of 
\begin_inset Formula $A$
\end_inset

 before moving on to the next block of 
\begin_inset Formula $x$
\end_inset

.
 
\newline

\newline
let 
\begin_inset Formula $y=A_{:,1:\alpha Z}x_{1:\alpha Z}$
\end_inset

 (first block)
\newline
let 
\begin_inset Formula $y=y+A_{:,(\alpha Z+1):2\alpha Z}x_{(\alpha Z+1):2\alpha Z}$
\end_inset

 (next block)
\newline

\emph on
et cetera,
\emph default
 for 
\emph on

\begin_inset Formula $m/(\alpha Z)$
\end_inset


\emph default
 blocks
\newline

\newline
Now, what should 
\begin_inset Formula $\alpha$
\end_inset

 be? Since we can't get any re-use for 
\begin_inset Formula $A$
\end_inset

, then we should read 
\begin_inset Formula $A$
\end_inset

 only one element at a time and then discard it; this means we only need
 to reserve one cache entry for 
\begin_inset Formula $A$
\end_inset

.
 Unfortunately, we have now introduced a new set of reads: 
\begin_inset Formula $y$
\end_inset

 has to be read in each time in order to add it to the next block.
 In the above algorithm, once 
\begin_inset Formula $m>Z$
\end_inset

 we can't really get cache reuse, like in part (b), and incur 
\begin_inset Formula $(\frac{m}{\alpha Z}-1)m\approx m^{2}/\alpha Z$
\end_inset

 misses.
 So, in that case we might as well reserve only one cache entry for reading
 in 
\begin_inset Formula $y$
\end_inset

 (i.e.
 reading it one entry at a time and then discarding form the cache).
 So 
\begin_inset Formula $\alpha Z=Z-2$
\end_inset

.
 By construction, 
\begin_inset Formula $x$
\end_inset

 is read into cache only once, for 
\begin_inset Formula $m$
\end_inset

 cache misses (asymptotically negligible compared to 
\begin_inset Formula $m^{2}$
\end_inset

).
 Thus, the total number of cache misses is 
\begin_inset Formula $m^{2}+m^{2}/(Z-2)\approx m^{2}(1+1/Z)\approx m^{2}$
\end_inset

.
 For large 
\begin_inset Formula $Z$
\end_inset

, this is a savings of about a factor of 2 over the naive algorithm---nothing
 to sneeze at, but nothing like the factor of 
\begin_inset Formula $\sqrt{Z}$
\end_inset

 we can save for a matrix-matrix multiply!
\newline

\newline
You might wonder whether we can
 gain some additional savings by blocking 
\begin_inset Formula $y$
\end_inset

 as well.
 That is, by doing the above algorithm in blocks of 
\begin_inset Formula $\approx Z/2$
\end_inset

 in 
\begin_inset Formula $y$
\end_inset

 and blocks of 
\begin_inset Formula $\approx Z/2$
\end_inset

 in 
\begin_inset Formula $x$
\end_inset

.
 However, in this case we would have to read in 
\begin_inset Formula $x$
\end_inset

 multiple times, and the number of cache misses would end up being 
\begin_inset Formula $m^{2}(1+2/Z)$
\end_inset

, slightly worse (essentially because we are only using half the cache for
 
\begin_inset Formula $x$
\end_inset

).
 There are other ways to re-arrange the algorithm as well, but none of them
 do better than 
\begin_inset Formula $m^{2}(1+1/Z)$
\end_inset

 as far as I can tell.
 In any case, for large 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 we are dominated by the 
\begin_inset Formula $m^{2}$
\end_inset

 misses to read in 
\begin_inset Formula $A$
\end_inset

, and there's nothing that can be done about this.
\end_layout

\begin_layout Enumerate
Yes.
 In the by-column matrix multiplication, we can see a huge drop in performance
 once the matrix size goes out of the L2 cache, whereas there is no such
 drop for the ordinary matrix multiplication because the 
\begin_inset Formula $1/\sqrt{Z}$
\end_inset

 factor makes the cache-miss cost negligible.
\newline

\newline
It ultimately achieves roughly
 the peak flop rate, as in class; note that if you have multiple CPUs, it
 may be impossible to prevent Matlab from using at least 2 processors.
 Even calling 
\family typewriter
maxNumCompThreads(1)
\family default
 as documented in the Matlab manual, it still used two processors for me
 in Matlab 7.6! 
\emph on
Grrr.

\emph default
 Hence, I got a peak flop rate of almost 10\InsetSpace ~
gflops on the 2.6GHz Intel Core
 2 (two processors, ~5\InsetSpace ~
gflops peak for each using SSE2 instructions).
\newline

\newline
Note
 that, for small matrix sizes, the performance is a lot lower in both cases,
 but especially in the by-column multiply.
 This is simply the overhead of the Matlab interpreter, which is much larger
 for the by-column case because that has a Matlab loop (versus a single
 Matlab call for the ordinary matrix-multiply).
 In both cases, the interpreter overhead (which is 
\begin_inset Formula $O(m)$
\end_inset

 in the by-column case) becomes negligible for large 
\begin_inset Formula $m$
\end_inset

, however.
\newline

\newline
(I'm not sure what the temporary drop in the ordinary matrix-multiply
 case is around 
\begin_inset Formula $m=100$
\end_inset

.)
\end_layout

\begin_layout Subsection*
Problem 4: Caches and backsubstitution
\end_layout

\begin_layout Enumerate
For each column we get a cache miss for each entry 
\begin_inset Formula $r_{ij}$
\end_inset

 of the matrix 
\begin_inset Formula $R$
\end_inset

, an there are roughly 
\begin_inset Formula $m^{2}/2$
\end_inset

 of these.
 For large enough 
\begin_inset Formula $m$
\end_inset

, where 
\begin_inset Formula $m^{2}>Z$
\end_inset

, these are no-longer in-cache and incur new misses on each column.
 Hence there are roughly 
\begin_inset Formula $m^{2}n/2$
\end_inset

, or 
\begin_inset Formula $\Theta(m^{2}n)$
\end_inset

 misses.
 (No asymptotic benefit from the cache.)
\end_layout

\begin_layout Enumerate
We can solve this problem in a cache-oblivious or cache-aware fashion.
 I find the cache-oblivious algorithm to be more beautiful, so let's do
 that.
 We'll divide 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $X$
\end_inset

, and 
\begin_inset Formula $B$
\end_inset

 into 
\begin_inset Formula $\frac{m}{2}\times\frac{m}{2}$
\end_inset

 blocks for sufficiently large 
\begin_inset Formula $m$
\end_inset

:
\begin_inset Foot
status collapsed

\begin_layout Standard
If 
\begin_inset Formula $m$
\end_inset

 is not even, then we round as needed: 
\begin_inset Formula $R_{11}$
\end_inset

 is 
\begin_inset Formula $\left\lceil \frac{m}{2}\right\rceil \times\left\lceil \frac{m}{2}\right\rceil $
\end_inset

, 
\begin_inset Formula $R_{12}$
\end_inset

 is 
\begin_inset Formula $\left\lceil \frac{m}{2}\right\rceil \times\left\lfloor \frac{m}{2}\right\rfloor $
\end_inset

, 
\begin_inset Formula $R_{21}$
\end_inset

 is 
\begin_inset Formula $\left\lfloor \frac{m}{2}\right\rfloor \times\left\lceil \frac{m}{2}\right\rceil $
\end_inset

, and 
\begin_inset Formula $R_{22}$
\end_inset

is 
\begin_inset Formula $\left\lfloor \frac{m}{2}\right\rfloor \times\left\lfloor \frac{m}{2}\right\rfloor $
\end_inset

; similarly for 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 
\end_layout

\end_inset

 
\begin_inset Formula \[
\left(\begin{array}{cc}
R_{11} & R_{12}\\
0 & R_{22}\end{array}\right)\left(\begin{array}{cc}
X_{11} & X_{12}\\
X_{21} & X_{22}\end{array}\right)=\left(\begin{array}{cc}
B_{11} & B_{12}\\
B_{21} & B_{22}\end{array}\right),\]

\end_inset

where 
\begin_inset Formula $R_{11}$
\end_inset

 and 
\begin_inset Formula $R_{22}$
\end_inset

 are upper-triangular.
 Now we solve this, analogous to backsubstitution, from bottom to top.
 First, for 
\begin_inset Formula $k=1,2$
\end_inset

, we solve 
\begin_inset Formula \[
R_{22}X_{2k}=B_{2k}\]

\end_inset

recursively for 
\begin_inset Formula $X_{2k}$
\end_inset

.
 Then, for 
\begin_inset Formula $k=1,2$
\end_inset

 we solve 
\begin_inset Formula \[
R_{11}X_{1k}=B_{1k}-R_{12}X_{2k}\]

\end_inset

recursively for 
\begin_inset Formula $X_{1k}$
\end_inset

.
 We use a cache-optimal algorithm (from class) for the dense matrix multiplies
 
\begin_inset Formula $R_{12}X_{2k}$
\end_inset

, which requires 
\begin_inset Formula $f(m)\in\Theta(m^{3}/\sqrt{Z})$
\end_inset

 misses for each 
\begin_inset Formula $\frac{m}{2}\times\frac{m}{2}$
\end_inset

 multiply.
 The number 
\begin_inset Formula $Q(m)$
\end_inset

 of cache misses then satisfies the recurrence: 
\begin_inset Formula \[
Q(m)=4Q(m/2)+2f(m)+4m^{2},\]

\end_inset

where the 
\begin_inset Formula $4Q(m/2)$
\end_inset

 is for the four recursive backsubsitutions and the 
\begin_inset Formula $4m^{2}$
\end_inset

 is for the two matrix subtractions 
\begin_inset Formula $B_{1k}-R_{12}X_{2k}$
\end_inset

.
 This recurrence terminates when the problem fits in cache, i.e.
 when 
\begin_inset Formula $2m^{2}+m^{2}/2\leq Z$
\end_inset

, at which point only 
\begin_inset Formula $\sim3m^{2}/2$
\end_inset

 misses are required.
 (Since we are only interested in the asymptotic 
\begin_inset Formula $\Theta$
\end_inset

 results, these little factors of 3 and 4 don't matter much, and I'll be
 dropping them soon.) Noting that 
\begin_inset Formula $f(m/2)\approx f(m)/8$
\end_inset

 , we can solve this recurrence as in class by just plugging it in a few
 times and seeing the pattern: 
\begin_inset Formula \begin{eqnarray*}
Q(m) & \approx & 4[4Q(m/4)+2f(m)/8+4m^{2}/4]+2f(m)+4m^{2}\\
 & = & 4^{2}Q(m/4)+2f(m)\,\left[1+\frac{1}{2}\right]+4m^{2}\,\left[1+1\right]\\
 & \approx & 4^{3}Q(m/8)+2f(m)\,\left[1+\frac{1}{2}+\frac{1}{2^{2}}\right]+4m^{2}\,\left[1+1+1\right]\\
 & \approx & \cdots\\
 & \approx & 4^{k}\Theta[(m/2^{k})^{2}]+2f(m)\,\left[1+\frac{1}{2}+\cdots+\frac{1}{2^{k-1}}\right]+4m^{2}\,\left[k\right]\\
 & \approx & \Theta(m^{2})+\Theta(m^{3}/\sqrt{Z})+\Theta(m^{2})k\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $\left[1+\frac{1}{2}+\cdots+\frac{1}{2^{k-1}}\right]\leq2$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 is the number of times we have to divide the problem to fit in cache, i.e.
 
\begin_inset Formula $3(m/2^{k})^{2}/2\approx Z$
\end_inset

 so 
\begin_inset Formula $k$
\end_inset

 is 
\begin_inset Formula $\Theta[\log(m^{2}/Z)]$
\end_inset

.
 Hence, for large 
\begin_inset Formula $m$
\end_inset

 where the 
\begin_inset Formula $m^{3}$
\end_inset

term dominates over the 
\begin_inset Formula $m^{2}$
\end_inset

 and 
\begin_inset Formula $m^{2}\log m$
\end_inset

 terms, we obtain 
\begin_inset Formula \[
Q(m;Z)\in\Theta(m^{3}/\sqrt{Z})\]

\end_inset

and hence we can, indeed, achieve the same asymptotic cache complexity as
 for matrix multiplication.
\newline

\newline
We could also get the same cache complexity in
 a cache-aware fashion by blocking the problem into 
\begin_inset Formula $m/b$
\end_inset

 blocks of size 
\begin_inset Formula $b\times b$
\end_inset

, where 
\begin_inset Formula $b$
\end_inset

 is some size in 
\begin_inset Formula $\Theta(\sqrt{Z})$
\end_inset

 chosen so that pairwise operations on the individual blocks fit in cache.
 Again, one would work on rows of blocks from bottom to top, and the algorithm
 would look much like the ordinary backsubstitution algorithm except that
 the numbers 
\begin_inset Formula $b_{ij}$
\end_inset

 etcetera are replaced by blocks.
 This is a perfectly acceptable answer, too.
\end_layout

\end_body
\end_document
