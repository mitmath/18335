#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble

\renewcommand{\vec}[1]{\mathbf{#1}}

\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{(\roman{enumii})}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\topmargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section*
18.335 Problem Set 1
\end_layout

\begin_layout Standard
Due Monday, 16 September 2013.
\end_layout

\begin_layout Subsection*
Problem 1: Gaussian elimination
\end_layout

\begin_layout Standard
Trefethen, problem 20.4.
\end_layout

\begin_layout Subsection*
Problem 2: Asymptotic notation
\end_layout

\begin_layout Standard
This problem asks a few simple questions to make sure that you understand
 the asymptotic notations 
\begin_inset Formula $O$
\end_inset

, 
\begin_inset Formula $\Omega$
\end_inset

, and 
\begin_inset Formula $\Theta$
\end_inset

 as defined in the handout in class, and also to make sure you are comfortable
 with simple proofs.
 (A detailed review of asymptotic notation can be found in any computer-science
 textbook, or on many sites online.)
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $f(n)$
\end_inset

 is 
\begin_inset Formula $\Theta[F(n)]$
\end_inset

 and 
\begin_inset Formula $g(n)$
\end_inset

 is 
\begin_inset Formula $\Theta[G(n)]$
\end_inset

 for nonnegative functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

, and 
\begin_inset Formula $G$
\end_inset

, prove that 
\begin_inset Formula $f(n)+g(n)$
\end_inset

 is 
\begin_inset Formula $\Theta[F(n)+G(n)]$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Prove that 
\begin_inset Formula $f(n)$
\end_inset

 is 
\begin_inset Formula $O[g(n)]$
\end_inset

 if and only if 
\begin_inset Formula $g(n)$
\end_inset

 is 
\begin_inset Formula $\Omega[f(n)]$
\end_inset

.
 [For example, 
\begin_inset Formula $n^{2}$
\end_inset

 is 
\begin_inset Formula $O(n^{3})$
\end_inset

 and 
\begin_inset Formula $n^{3}$
\end_inset

 is 
\begin_inset Formula $\Omega(n^{2})$
\end_inset

.]
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $f(n)$
\end_inset

 is 
\begin_inset Formula $O[F(n)]$
\end_inset

, prove that any function that is 
\begin_inset Formula $O[f(n)+c\, F(n)]$
\end_inset

 must also be 
\begin_inset Formula $O[F(n)]$
\end_inset

 for any constant 
\begin_inset Formula $c\neq0$
\end_inset

---that is, if we regard 
\begin_inset Formula $O[\cdots]$
\end_inset

 as a set of functions, prove 
\begin_inset Formula $O[f(n)+c\, F(n)]\subseteq O[F(n)]$
\end_inset

.
 [For example, 
\begin_inset Formula $O(n^{2}+3n^{3})=O(n^{3})$
\end_inset

.] 
\end_layout

\begin_layout Enumerate
Explain why the statement, 
\begin_inset Quotes eld
\end_inset

The running time of this algorithm is 
\begin_inset Formula $O(n^{2})$
\end_inset

 or worse,
\begin_inset Quotes erd
\end_inset

 cannot (if taken literally) provide any information about the algorithm.
\end_layout

\begin_layout Subsection*
Problem 3: Caches and matrix multiplications
\end_layout

\begin_layout Standard
In class, we considered the performance and cache complexity of matrix multiplic
ation 
\begin_inset Formula $A=BC$
\end_inset

, especially for square 
\begin_inset Formula $m\times m$
\end_inset

 matrices, and showed how to reduce the number of cache misses using various
 forms of blocking.
 In this problem, you will be comparing optimized matrix-matrix products
 to optimized matrix-vector products, using Julia.
\end_layout

\begin_layout Enumerate
The code 
\family typewriter
matmul_bycolumn.jl
\family default
 posted on the 18.335 web page computes 
\begin_inset Formula $A=BC$
\end_inset

 by multiplying 
\begin_inset Formula $B$
\end_inset

 by each column of 
\begin_inset Formula $C$
\end_inset

 individually (using Julia's highly-optimized OpenBLAS matrix-vector product).
 Benchmark this: plot the flop rate for square 
\begin_inset Formula $m\times m$
\end_inset

 matrices as a function of 
\begin_inset Formula $m$
\end_inset

, and also benchmark Julia's built-in matrix-matrix product and plot it
 too.
 For example, Julia code to benchmark Julia's 
\begin_inset Formula $m\times m$
\end_inset

 products for 
\begin_inset Formula $m$
\end_inset

 from 10 to 1000 (logarithmically spaced), storing the flop rate (
\begin_inset Formula $2m^{3}$
\end_inset

/nanoseconds) in an array 
\family typewriter
gflops
\family default
 and plotting the result, is: 
\begin_inset CommandInset include
LatexCommand verbatiminput
filename "benchmul.jl"

\end_inset


\end_layout

\begin_layout Enumerate
Compute the cache complexity (the asymptotic number of cache misses in the
 ideal-cache model, as in class) of an 
\begin_inset Formula $m\times m$
\end_inset

 matrix-vector product implemented the 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 way (a sequence of row
\begin_inset Formula $\cdot$
\end_inset

column dot products).
 
\end_layout

\begin_layout Enumerate
Propose an algorithm for matrix-vector products that obtains a better asymptotic
 cache complexity (or at least a better constant coefficient, e.g.
 going from 
\begin_inset Formula $\sim3m^{2}$
\end_inset

 to 
\begin_inset Formula $\sim2m^{2}$
\end_inset

, even if it is still the same 
\begin_inset Formula $\Theta[\cdots]$
\end_inset

 complexity) by dividing the operation into some kind of blocks.
\end_layout

\begin_layout Enumerate
Assuming Julia uses something like your 
\begin_inset Quotes eld
\end_inset

improved
\begin_inset Quotes erd
\end_inset

 algorithm from part (c) to do matrix-vector products, compute the cache
 complexity of 
\family typewriter
matmul_bycolumn
\family default
.
 Compare this to the cache complexity of the blocked matrix-matrix multiply
 from class.
 Does this help to explain your results from part (a)?
\end_layout

\begin_layout Subsection*
Problem 4: Caches and backsubstitution
\end_layout

\begin_layout Standard
In this problem, you will consider the impact of caches (again in the ideal-cach
e model from class) on the problem of 
\emph on
backsubstitution
\emph default
: solving 
\begin_inset Formula $Rx=b$
\end_inset

 for 
\begin_inset Formula $x$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 is an 
\begin_inset Formula $m\times m$
\end_inset

 upper-triangular matrix (such as might be obtained by Gaussian elimination).
 The simple algorithm you probably learned in previous linear-algebra classes
 (and reviewed in the book, lecture 17) is (processing the rows from bottom
 to top): 
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $x_{m}=b_{m}/r_{mm}$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
for
\series default
 
\begin_inset Formula $j=m-1$
\end_inset

 down to 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout LyX-Code
   
\begin_inset Formula $x_{j}=(b_{j}-\sum_{k=j+1}^{m}r_{jk}x_{k})/r_{jj}$
\end_inset


\end_layout

\begin_layout Standard
Suppose that 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are 
\begin_inset Formula $m\times n$
\end_inset

 matrices, and we want to solve 
\begin_inset Formula $RX=B$
\end_inset

 for 
\begin_inset Formula $X$
\end_inset

---this is equivalent to solving 
\begin_inset Formula $Rx=b$
\end_inset

 for 
\begin_inset Formula $n$
\end_inset

 different right-hand sides 
\begin_inset Formula $b$
\end_inset

 (the 
\begin_inset Formula $n$
\end_inset

 columns of 
\begin_inset Formula $B$
\end_inset

).
 One way to solve the 
\begin_inset Formula $RX=B$
\end_inset

 for 
\begin_inset Formula $X$
\end_inset

 is to apply the standard backsubstitution algorithm, above, to each of
 the 
\begin_inset Formula $n$
\end_inset

 columns in sequence.
\end_layout

\begin_layout Enumerate
Give the asymptotic cache complexity 
\begin_inset Formula $Q(m,n;Z)$
\end_inset

 (in asymptotic 
\begin_inset Formula $\Theta$
\end_inset

 notation, ignoring constant factors) of this algorithm for solving 
\begin_inset Formula $RX=B$
\end_inset

.
\end_layout

\begin_layout Enumerate
Suppose 
\begin_inset Formula $m=n$
\end_inset

.
 Propose an algorithm for solving 
\begin_inset Formula $RX=B$
\end_inset

 that achieves a better asymptotic cache complexity (by cache-aware/blocking
 or cache-oblivious algorithms, your choice).
 Can you gain the factor of 
\begin_inset Formula $1/\sqrt{Z}$
\end_inset

 savings that we showed is possible for square-matrix multiplication? 
\end_layout

\end_body
\end_document
